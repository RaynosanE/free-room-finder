#!/usr/bin/env python2
###############################################################################
#
# A script which parses the course entries displayed by the UOIT
# website http://www.uoit.ca/mycampus/avail_courses.html and stores
# each of the rooms, times they are used, and other important information
# in a database.
#
# Copyright (C) 2013, Jonathan Gillett, Joseph Heron, and Daniel Smullen
# All rights reserved.
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

from BeautifulSoup import BeautifulSoup
from urllib import FancyURLopener
from termcolor import colored
from datetime import *
from regex import *
from dbinterface import *
from acronyms import *
from util import *
import string
import sys
import traceback


class Opener(FancyURLopener):
    """
    The Opener class, define the browser user agent used
    """
    version = 'Mozilla/5.0 (X11; Linux i686; rv:5.0) Gecko/20100101 Firefox/5.0'


def CourseContent(url):
    """Function which returns the html content of the course lookup
    """
    content = BeautifulSoup(Opener().open(url).read())
    return content


def getURL(campus, faculty, semester, year):
    """A function which returns a url to get the course schedule based on the
    campus and faculty.
    """
    url = 'https://ssbprod.aac.mycampus.ca/prod/bwckschd.p_get_crse_unsec'
    url += '?TRM=U&begin_ap=a&begin_hh=0&begin_mi=0&end_ap=a&end_hh=0&end_mi=0&sel_attr=dummy'
    url += campuses[campus]
    url += '&sel_crse=&sel_day=dummy&sel_from_cred=&sel_insm=dummy&sel_instr=dummy&sel_levl=dummy&sel_ptrm=dummy'
    url += '&sel_schd=dummy&sel_sess=dummy&sel_subj=dummy&sel_subj='
    url += faculty
    url += '&sel_title=&sel_to_cred=&term_in='
    url += year
    url += semester
    return url

          
def store_course_data(con, course_data):
    """
    Function that stores course data in the database, accepts the 3-D dictionary
    generated by the get_course_data function

    Algorithm for storing the data:
    for each key 0..
        for each key that is a..z (alphanumeric)
            if table does not exist for current room [0..][a..][room_number]
                create new table
            insert into table all the values for current [0..][a..][<keys>]
            and the values from the [0..][<keys>]
    """
    for idx_key in course_data:
        for alp_key in course_data[idx_key]:
            if re.match(re.compile(r'^[a-zA-Z]{1}$'), alp_key):
                # Some courses such as capstone and online courses don't have a room
                #if 'room_number' not in course_data[idx_key][alp_key] or \
                #    'day' not in course_data[idx_key][alp_key]:
                #    break
                    
                #if 'start_time' not in course_data[idx_key][alp_key] and \
                #    'finish_time' not in course_data[idx_key][alp_key]:
                #    break
                
                # If table does not exist for current room, create a new table
                #if table_exists(con, course_data[idx_key][alp_key]['room_number']) is False:
                #    print "CREATING TABLE", course_data[idx_key][alp_key]['room_number']
                #    create_table_room(con, course_data[idx_key][alp_key]['room_number'])
                # Insert the data for the current table
                try:
                    # Print out 'NONE' in red for anything that's set as None
                    """
                    for key in course_data[idx_key]:
                        if course_data[idx_key][key] is None:
                            course_data[idx_key][key] = colored('NONE', 'red')

                    for key in course_data[idx_key][alp_key]:
                        if course_data[idx_key][alp_key][key] is None:
                            course_data[idx_key][alp_key][key] = colored('NONE', 'red')
                    """
                    print "COURSE NAME:", course_data[idx_key]['course_name']
                    print "COURSE CRN:", course_data[idx_key]['crn']
                    print "PROGRAM CODE:", course_data[idx_key]['program_code']
                    print "COURSE CODE:", course_data[idx_key]['course_code']
                    print "COURSE SECTION:", course_data[idx_key]['course_section']
                    print "COURSE TERM:", course_data[idx_key]['term'][0]
                    print "COURSE LEVEL:", course_data[idx_key]['level']
                    print "TEACHER NAME:", course_data[idx_key]['teacher_name']
                    #print "CAMPUS:", course_data[idx_key]['campus']
                    print "COURSE DATA:", course_data[idx_key]

                    print "CAPACITY:", course_data[idx_key]['capacity']
                    print "REGISTERED:", course_data[idx_key]['registered']

                    print "WEEK ALT:", course_data[idx_key][alp_key]['week_alt']
                    print "START TIME:", course_data[idx_key][alp_key]['start_time']
                    print "FINISH TIME:", course_data[idx_key][alp_key]['finish_time']
                    print "DAY OF WEEK:", course_data[idx_key][alp_key]['day']
                    print "ROOM:", course_data[idx_key][alp_key]['room_number']
                    print "START DATE:", course_data[idx_key][alp_key]['date_start']
                    print "FINISH DATE:", course_data[idx_key][alp_key]['date_finish']
                    print "CLASS TYPE:", course_data[idx_key][alp_key]['class_type'], "\n"

                    # offerings dictionary containing items to insert into the database
                    # see the insert_offerings method for a description of the dictionary
                    offerings = {   'course_name':      course_data[idx_key]['course_name'],
                                    'crn':              course_data[idx_key]['crn'],
                                    'program_code':     course_data[idx_key]['program_code'],
                                    'course_code':      course_data[idx_key]['course_code'],
                                    'course_section':   course_data[idx_key]['course_section'],
                                    'level':            course_data[idx_key]['level'],
                                    'class_type':       course_data[idx_key][alp_key]['class_type'],
                                    'teacher_name':     course_data[idx_key]['teacher_name'],
                                    'room_number':      course_data[idx_key][alp_key]['room_number'], 
                                    'campus':           course_data[idx_key]['campus'], 
                                    'capacity':         course_data[idx_key]['capacity'],
                                    'registered':       course_data[idx_key]['registered'],
                                    'start_time':       course_data[idx_key][alp_key]['start_time'],
                                    'finish_time':      course_data[idx_key][alp_key]['finish_time'], 
                                    'start_date':       course_data[idx_key][alp_key]['date_start'],
                                    'finish_date':      course_data[idx_key][alp_key]['date_finish'],
                                    'day':              course_data[idx_key][alp_key]['day'], 
                                    'week_alt':         course_data[idx_key][alp_key]['week_alt'],   
                                    'year':             course_data[idx_key]['term'][1],
                                    'semester':         course_data[idx_key]['term'][0]
                                }

                    # Insert the data into the database using the database interface
                    insert_offering(con, offerings)
                except:
                    #print "Error %d: %s" % (e.args[0],e.args[1])
                    traceback.print_exc(file=sys.stdout)
                    sys.exit(1)


def get_course_data(campus, faculty, semester, year):
    """A function which parses the data and stores it in a multidimensional dictionary
    with the following structure

    <--                            dictionary                   -->
    <key>               <--              dictionary             -->
                                          <--     dictionary    -->
                        <key>               <key>               <value>
    {'0'     =>    {    {'a'        =>    'day'          =>  'M/T/W/R/F'
                                          'start_time'   =>  ('8:10', 'am')
                                          'finish_time'  =>  ('10:00', 'am')
                                          'date_start'   =>  ('Jan', '09', '2012')4
                                          'date_finish'  =>  ('Apr', '13', '2012')
                                          'class_type'   =>  'LEC/TUT/LAB'
                                          'room_number'  =>  'UA1350'
                                          'week1'        =>  True/False
                                          'week2'        =>  True/False
                         }
                         'teacher_name' =>  'Judith Grant'
                         'capacity'     =>  250
                         'registered'   =>  236
                         'term'         =>  ('Winter', '2012')
                         'crn'          =>  '70483'
                         'course_name'  =>  'Introductory Sociology'
                         'program_code' =>  'SOCI'
                         'course_code'  =>  '1000U'
                         'course_secion'=>  '001'
                         'level'        =>  'Undergraduate'
                         'campus'       =>  'UON/UOD/UOG'
                   }
    }
    """
    # 3-D dictionary containing the course data and index keys
    course_data = {}

    # Get the html content from the uoit class schedule listing webpage
    course_content = CourseContent(getURL(campus, faculty, semester, year))
    
    # Parse all the course information in the first section of table
    parse_course_info(course_content, course_data)
    
    # Parse all the registration information in the second table
    parse_reg_info(course_content, course_data)
    
    # Parse all the classroom meeting times in the third table
    parse_class_time(course_content, course_data)
    
    return course_data


def parse_course_info(course_content, course_data):
    """A function which parses all the course information in the first section of table
    Arguments are the BeatifulSoup object course_content containing the website
    HTML content and a 3-D dictionary containing the course data and index keys 
    which is used by get_course_data()
    """
    # Parses all the course information in the first table
    for course_table in course_content.findAll('table', {'class': "datadisplaytable", 'summary': 
                                "This layout table is used to present the sections found"}):
        # Finds all instances of course info
        idx_key = 0
        for row in course_table.findAll('th', {'class': "ddheader", 'scope': "col"}, True, re_course_info):
            match = re_course_info.search(str(row).strip())
            if match is not None:
                #print "course info", idx_key
                # Store the course information parsed 3-D dictionary, course_data
                (course_name, crn, program_code, course_code, course_section) = match.group(1, 2, 3, 4, 5)
                # Remove all punctuation for the course name, replace "amp" with &
                course_data[idx_key] = {'course_name': course_name.replace("&amp;", "&")}
                course_data[idx_key]['crn'] = crn
                course_data[idx_key]['program_code'] = program_code
                course_data[idx_key]['course_code'] = course_code
                course_data[idx_key]['course_section'] = course_section
                idx_key += 1
                
        # Finds all instances of course term info
        idx_key = 0
        for row in course_table.findAll('span', {'class': "fieldlabeltext"}, True, re.compile(r'Associated\sTerm\:\s')):
            match = re_course_term.search(str(row.next).strip())
            if match is not None:
                #print "course term", idx_key
                course_data[idx_key]['term'] = match.group(2, 3)
                idx_key += 1
                     
        # Finds all instances of course level (Undergraduate, Graduate, etc.)
        idx_key = 0
        for row in course_table.findAll('span', {'class': "fieldlabeltext"}, True, re.compile(r'Levels\:\s')):
            match = re_course_level.search(str(row.next).strip())
            if match is not None:
                course_data[idx_key]['level'] = match.group(1)
            else:
                course_data[idx_key]['level'] = None
            idx_key += 1

        # Finds all instances of campus
        idx_key = 0
        for row in course_table.findAll(['span', 'b'], {'class': "fieldlabeltext"}, True, re.compile(r'Campus')):
            match = re_campus.search(str(row).strip())
            if match is not None:
                # Store the acronym for each campus, lookup acronym in dictionary
                #print "campus", idx_key
                if match.group(2) is not None:
                    course_data[idx_key]['campus'] = reverse_lookup(campus_acronyms, match.group(2).strip())
                # Case where UOIT North Oshawa Campus (UON) is shown as just Oshawa Campus
                elif match.group(3) is not None:
                    if match.group(3).strip() == "Oshawa Campus":
                        course_data[idx_key]['campus'] = reverse_lookup(campus_acronyms, "North Oshawa Campus")
                    elif match.group(3).strip() == "Offsite Campus":
                        course_data[idx_key]['campus'] = reverse_lookup(campus_acronyms, "Other Campus")
                    else:
                        course_data[idx_key]['campus'] = None
                idx_key += 1
            # TODO this needs to be handled because online courses are still linked to campus even thoug there is no room
            else:
                course_data[idx_key]['campus'] = None

        # Parse the professors name
        idx_key = 0
        for meeting_table in course_table.findAll('table', {'class': "bordertable", 'summary': 
                                "This table lists the scheduled meeting times and assigned instructors for this class."}):
            # Grab the 2nd <tr> of meetings times table, to get the professors name
            for row in meeting_table.findAll('tr')[1:2]:
                for column in row.findAll('td', {'class': "dbdefault"}, True)[7:8]:
                    match = re_prof_name.search(str(column).strip())
                    
                    if match is not None:
                        # Professors name is listed
                        if match.group(1) is not None:
                            course_data[idx_key]['teacher_name'] = match.group(1)
                        # professor listed as TBA, None specfied for course
                        elif match.group(2) is not None:
                            course_data[idx_key]['teacher_name'] = None
                    # No professor name listed, None specfied for course
                    else:
                        course_data[idx_key]['teacher_name'] = None
                    idx_key += 1


def parse_reg_info(course_content, course_data):
    """A function which parses all the registration information in the second table
    Arguments are the BeatifulSoup object course_content containing the website
    HTML content and a 3-D dictionary containing the course data and index keys 
    which is used by get_course_data()
    """
    # Parses all the registration information in the second table
    idx_key = 0
    for reg_table in course_content.findAll('table', {'class': "bordertable", 'summary': 
                            "This layout table is used to present the seating numbers."}):
        # Finds all instances of the capacity
        for row in reg_table.findAll('td', {'class': 'dbdefault'}, True, re_capacity)[0:1]:
            # Store the capacity of the room
            course_data[idx_key]['capacity'] = int(row)
            
        # Finds all instances of the number students registered
        for row in reg_table.findAll('td', {'class': 'dbdefault'}, True, re_capacity)[1:2]:
            # Store the number students registered
            course_data[idx_key]['registered'] = int(row)
            idx_key += 1


def parse_class_time(course_content, course_data):
    """A Function which parses all the classroom meeting times in the third table
    Arguments are the BeatifulSoup object course_content containing the website
    HTML content and a 3-D dictionary containing the course data and index keys 
    which is used by get_course_data().
    """
    # Parses all the classroom meeting times
    idx_key = 0
    for meeting_table in course_content.findAll('table', {'class': "bordertable", 'summary': 
                            "This table lists the scheduled meeting times and assigned instructors for this class."}):
        # Find all the classroom meeting time info for each day
        alp_key = 'a'
        for row in meeting_table.findAll('tr'):
            ### Each column is the information for each day the classroom is used
            # Parse the week info, if room is used during week1, week2, or both
            for column in row.findAll('td', {'class': "dbdefault"}, True, re_week_info)[0:1]:
                # NO ALTERNATING WEEKS
                if re.match(re.compile(r'^&nbsp;$'), column.strip()):
                    course_data[idx_key][alp_key] = {'week_alt': None}
                # WEEK 1 ALTERNATING
                elif re.match(re.compile(r'^(&nbsp;)*W1$'), column.strip()):
                    course_data[idx_key][alp_key] = {'week_alt': True}
                # WEEK 2 ALTERNATING
                elif re.match(re.compile(r'^(&nbsp;)*W2$'), column.strip()):
                    course_data[idx_key][alp_key] = {'week_alt': False}
                # WEEK 3 ALTERNATING
                # TODO FIX DATABASE DOES NOT HAVE SUPPORT FOR W3, ATM TREATING W3 AS W1 
                elif re.match(re.compile(r'^(&nbsp;)*W3$'), column.strip()):
                    course_data[idx_key][alp_key] = {'week_alt': True}

            # Parse the course start and end time
            for column in row.findAll('td', {'class': "dbdefault"}, True)[2:3]:
                match = re_course_time.search(str(column).strip())
                if match is not None:
                    course_data[idx_key][alp_key]['start_time'] = convert_time(match.group(1, 2))
                    course_data[idx_key][alp_key]['finish_time'] = convert_time(match.group(3, 4))
                # The course does NOT have specific times for classes
                else:
                    course_data[idx_key][alp_key]['start_time'] = None
                    course_data[idx_key][alp_key]['finish_time'] = None
                    
            # Parse the course day of the week (single char, ie. M for Monday)
            for column in row.findAll('td', {'class': "dbdefault"}, True)[3:4]:
                match = re_course_day.search(str(column).strip())
                if match is not None:
                    course_data[idx_key][alp_key]['day'] = match.group(1)
                # The course does NOT have specific days for classes
                else:
                    course_data[idx_key][alp_key]['day'] = None
                    
            # Parse the room, right now only gets room number (ie. UA1350)
            for column in row.findAll('td', {'class': "dbdefault"}, True)[4:5]:
                # If it is an online course (ie. ONLINE) then there is no room specified
                # TODO online courses have no room but have a CAMPUS, may need to investigate handling this
                # for DB insert operations...
                # TODO this has to be here to handline instances such as ONLINE2 as it screws up the room number
                # for online courses where classroom is ONLINE2 the second regex will parse INE2.... lol
                match = re_room_online.search(str(column).strip())
                if match is not None:
                    course_data[idx_key][alp_key]['room_number'] = None
                    continue

                # Otherwise get the room number (ie. UA1350)    
                match = re_room.search(str(column).strip())
                if match is not None:
                    course_data[idx_key][alp_key]['room_number'] = match.group(1)
                # TODO see if there are any where the location is just blank...
                else:
                    course_data[idx_key][alp_key]['room_number'] = None
                    
            # Parse the course start and end date
            for column in row.findAll('td', {'class': "dbdefault"}, True)[5:6]:
                match = re_course_date.search(str(column).strip())
                if match is not None:
                    course_data[idx_key][alp_key]['date_start']  = convert_date(match.group(1, 2, 3))
                    course_data[idx_key][alp_key]['date_finish'] = convert_date(match.group(4, 5, 6))
                # TODO are there any courses where the start/end date is not specified? Should the DB require
                # a start and end date for a course, atm it can be NULL
                else:
                    course_data[idx_key][alp_key]['date_start']  = None
                    course_data[idx_key][alp_key]['date_finish'] = None
                    
            # Parse the type of class, Lecture, Tutorial, Laboratory
            for column in row.findAll('td', {'class': "dbdefault"}, True)[6:7]:
                match = re_class_type.search(str(column).strip())
                if match is not None:
                    #print "CLASS TYPE: ", ">>" + match.group(1) + "<<"
                    course_data[idx_key][alp_key]['class_type'] = reverse_lookup(class_types, match.group(1).strip())
                    #print "\n\nDEBUG:"
                    #print idx_key
                    #print alp_key
                    #print course_data[idx_key][alp_key]
                # TODO look for unhandled class types, need to add them to dictionary
                else:
                    course_data[idx_key][alp_key]['class_type'] = None
                
                alp_key = chr(ord(alp_key) + 1)

        idx_key += 1


# Mysql Database connection information
con = None
user = 'jon'
passwd = 'test123'
domain = 'localhost'
db_name = 'free_room_finder'


# Current month, year semester
#cur_month = datetime.now().month
#cur_year = str(datetime.now().year)     # Year is ALWAYS used as a string
#cur_month = int(sys.argv[1])
cur_semester = str(sys.argv[1])
cur_year = str(sys.argv[2])


# Get the current semester based on the current month, anything from 01 - 04
# is winter, 05 - 08 is summer, 09 - 12 is winter
#if cur_month >= 1 and cur_month < 5:
#    cur_semester = 'winter'
#elif cur_month >= 5 and cur_month < 9:
#    cur_semester = 'summer'
#else:
#    cur_semester = 'fall'


# Create a new database for the current semester and year, if
# an existing database exists it will be deleted and overwritten
#con = connect_db(user, passwd, domain, '')
#create_db(con, cur_semester, cur_year)

con = connect_db(user, passwd, domain, db_name)


# Get the course data for each faculty and store it in the database
for faculty in faculties:
    print "PARSING %s" % (faculty)
    course_data = get_course_data('ALL', faculty, semester[cur_semester], cur_year)
    store_course_data(con, course_data)

# Commit all changes to the database before closing connection
con.commit()

# Finally, close connection to database
con.close()
